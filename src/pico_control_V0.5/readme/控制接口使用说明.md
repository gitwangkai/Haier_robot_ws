# 控制接口使用说明

本文档说明如何在前端按钮界面调用四个核心控制接口。

## 接口概述

| 接口名称 | 功能描述 | Socket.IO事件 |
|---------|---------|--------------|
| 开始播放 | 播放指定的动作文件 | `start_playback` |
| 停止播放 | 停止当前正在播放的动作 | `stop_playback` |
| 重置位姿 | 将双臂重置到初始安全位置 | `reset_pose` |
| 刷新状态 | 获取并显示机械臂当前状态 | `get_status` |

---

## 1. 开始播放接口

### 功能说明
从JSON文件读取录制的动作数据，并控制机械臂执行回放。支持调节播放速度。

### Socket.IO事件
```javascript
socket.emit('start_playback', {
    filename: 'record_20260127_123456.json',
    speed: 1.0
});
```

### 参数说明
- `filename` (必需): 动作文件名，必须存在于 `arm_data` 目录中
- `speed` (可选): 播放速度倍率，默认1.0，范围0.1-10.0

### 返回事件
- `playback_started`: 播放开始时触发
  ```javascript
  socket.on('playback_started', (data) => {
      console.log('播放开始:', data.filename, '速度:', data.speed);
  });
  ```

- `playback_progress`: 播放进度更新
  ```javascript
  socket.on('playback_progress', (data) => {
      console.log(`进度: ${data.current}/${data.total}`);
      console.log(`百分比: ${(data.progress * 100).toFixed(1)}%`);
  });
  ```

- `playback_stopped`: 播放停止时触发
  ```javascript
  socket.on('playback_stopped', () => {
      console.log('播放已停止');
  });
  ```

- `playback_failed`: 播放失败时触发
  ```javascript
  socket.on('playback_failed', (data) => {
      console.error('播放失败:', data.error);
  });
  ```

### 前端按钮示例
```html
<button id="start-playback-btn">开始播放</button>
<select id="playback-file">
    <option value="record_20260127_123456.json">动作1</option>
    <option value="record_20260127_234567.json">动作2</option>
</select>
<input type="number" id="playback-speed" value="1.0" step="0.1" min="0.1">
```

```javascript
document.getElementById('start-playback-btn').addEventListener('click', () => {
    const filename = document.getElementById('playback-file').value;
    const speed = parseFloat(document.getElementById('playback-speed').value);
    
    socket.emit('start_playback', {
        filename: filename,
        speed: speed
    });
});
```

---

## 2. 停止播放接口

### 功能说明
立即停止当前正在播放的动作。

### Socket.IO事件
```javascript
socket.emit('stop_playback');
```

### 参数说明
无参数

### 返回事件
- `playback_stopped`: 停止时触发
  ```javascript
  socket.on('playback_stopped', () => {
      console.log('播放已停止');
  });
  ```

### 前端按钮示例
```html
<button id="stop-playback-btn">停止播放</button>
```

```javascript
document.getElementById('stop-playback-btn').addEventListener('click', () => {
    socket.emit('stop_playback');
});
```

---

## 3. 重置位姿接口

### 功能说明
将双臂移动到预设的安全初始位置。初始角度为 [120, 120, 120, 120, 120, 120, 80]。

### Socket.IO事件
```javascript
socket.emit('reset_pose');
```

### 参数说明
无参数

### 返回事件
- `pose_reset_complete`: 重置完成时触发
  ```javascript
  socket.on('pose_reset_complete', (data) => {
      console.log('位姿重置完成');
  });
  ```

- `arm_status`: 状态自动刷新
  ```javascript
  socket.on('arm_status', (data) => {
      console.log('右臂状态:', data.right);
      console.log('左臂状态:', data.left);
  });
  ```

### 前端按钮示例
```html
<button id="reset-pose-btn">重置位姿</button>
```

```javascript
document.getElementById('reset-pose-btn').addEventListener('click', () => {
    socket.emit('reset_pose');
});
```

---

## 4. 刷新状态接口

### 功能说明
获取并显示机械臂的当前状态，包括每个舵机的位置、电压、温度和负载信息。

### Socket.IO事件
```javascript
socket.emit('get_status');
```

### 参数说明
无参数

### 返回事件
- `arm_status`: 状态数据
  ```javascript
  socket.on('arm_status', (data) => {
      // 右臂状态
      for (const [servoId, status] of Object.entries(data.right)) {
          console.log(`右臂舵机 ${servoId}:`);
          console.log(`  位置: ${status.pos}`);
          console.log(`  电压: ${status.volt}V`);
          console.log(`  温度: ${status.temp}°C`);
          console.log(`  负载: ${status.load}`);
      }
      
      // 左臂状态
      for (const [servoId, status] of Object.entries(data.left)) {
          console.log(`左臂舵机 ${servoId}:`);
          console.log(`  位置: ${status.pos}`);
          console.log(`  电压: ${status.volt}V`);
          console.log(`  温度: ${status.temp}°C`);
          console.log(`  负载: ${status.load}`);
      }
  });
  ```

### 前端按钮示例
```html
<button id="refresh-status-btn">刷新状态</button>
```

```javascript
document.getElementById('refresh-status-btn').addEventListener('click', () => {
    socket.emit('get_status');
});
```

---

## 完整前端集成示例

### HTML部分
```html
<!DOCTYPE html>
<html>
<head>
    <title>机械臂控制面板</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
</head>
<body>
    <h1>机械臂控制面板</h1>
    
    <!-- 播放控制 -->
    <div class="control-section">
        <h2>播放控制</h2>
        <label for="playback-file">选择动作文件:</label>
        <select id="playback-file">
            <option value="">请选择文件...</option>
        </select>
        
        <label for="playback-speed">播放速度:</label>
        <input type="number" id="playback-speed" value="1.0" step="0.1" min="0.1">
        
        <button id="start-playback-btn">开始播放</button>
        <button id="stop-playback-btn" disabled>停止播放</button>
        
        <div id="playback-progress">
            <div class="progress-bar"></div>
        </div>
    </div>
    
    <!-- 位姿控制 -->
    <div class="control-section">
        <h2>位姿控制</h2>
        <button id="reset-pose-btn">重置位姿</button>
    </div>
    
    <!-- 状态监控 -->
    <div class="control-section">
        <h2>状态监控</h2>
        <button id="refresh-status-btn">刷新状态</button>
        <div id="status-display">
            <h3>右臂状态</h3>
            <div id="right-arm-status"></div>
            <h3>左臂状态</h3>
            <div id="left-arm-status"></div>
        </div>
    </div>
    
    <script src="control.js"></script>
</body>
</html>
```

### JavaScript部分 (control.js)
```javascript
// 初始化Socket.IO连接
const socket = io();

// 获取DOM元素
const playbackFileSelect = document.getElementById('playback-file');
const playbackSpeedInput = document.getElementById('playback-speed');
const startPlaybackBtn = document.getElementById('start-playback-btn');
const stopPlaybackBtn = document.getElementById('stop-playback-btn');
const playbackProgressBar = document.querySelector('#playback-progress .progress-bar');
const resetPoseBtn = document.getElementById('reset-pose-btn');
const refreshStatusBtn = document.getElementById('refresh-status-btn');
const rightArmStatusDiv = document.getElementById('right-arm-status');
const leftArmStatusDiv = document.getElementById('left-arm-status');

// ==================== Socket.IO事件监听 ====================

// 播放开始
socket.on('playback_started', (data) => {
    console.log('播放开始:', data.filename);
    startPlaybackBtn.disabled = true;
    stopPlaybackBtn.disabled = false;
    playbackProgressBar.style.width = '0%';
    playbackProgressBar.textContent = '0%';
});

// 播放进度
socket.on('playback_progress', (data) => {
    const progress = (data.current / data.total) * 100;
    playbackProgressBar.style.width = `${progress}%`;
    playbackProgressBar.textContent = `${data.current}/${data.total} (${progress.toFixed(1)}%)`;
});

// 播放停止
socket.on('playback_stopped', () => {
    console.log('播放已停止');
    startPlaybackBtn.disabled = false;
    stopPlaybackBtn.disabled = true;
    playbackProgressBar.style.width = '0%';
    playbackProgressBar.textContent = '';
});

// 播放失败
socket.on('playback_failed', (data) => {
    console.error('播放失败:', data.error);
    alert('播放失败: ' + data.error);
    startPlaybackBtn.disabled = false;
    stopPlaybackBtn.disabled = true;
});

// 位姿重置完成
socket.on('pose_reset_complete', (data) => {
    console.log('位姿重置完成');
    alert('位姿已重置');
});

// 状态更新
socket.on('arm_status', (data) => {
    displayStatus(data.right, rightArmStatusDiv, '右臂');
    displayStatus(data.left, leftArmStatusDiv, '左臂');
});

// ==================== 按钮事件监听 ====================

// 开始播放
startPlaybackBtn.addEventListener('click', () => {
    const filename = playbackFileSelect.value;
    if (!filename) {
        alert('请先选择动作文件');
        return;
    }
    
    const speed = parseFloat(playbackSpeedInput.value);
    
    socket.emit('start_playback', {
        filename: filename,
        speed: speed
    });
});

// 停止播放
stopPlaybackBtn.addEventListener('click', () => {
    socket.emit('stop_playback');
});

// 重置位姿
resetPoseBtn.addEventListener('click', () => {
    if (confirm('确定要重置双臂位姿吗？')) {
        socket.emit('reset_pose');
    }
});

// 刷新状态
refreshStatusBtn.addEventListener('click', () => {
    socket.emit('get_status');
});

// ==================== 辅助函数 ====================

function displayStatus(status, container, armName) {
    let html = '';
    for (const [servoId, info] of Object.entries(status)) {
        html += `
            <div class="servo-status">
                <h4>舵机 ${servoId}</h4>
                <p>位置: ${info.pos !== null ? info.pos : '离线'}</p>
                <p>电压: ${info.volt !== null ? info.volt.toFixed(2) + 'V' : '未知'}</p>
                <p>温度: ${info.temp !== null ? info.temp + '°C' : '未知'}</p>
                <p>负载: ${info.load !== null ? info.load : '未知'}</p>
            </div>
        `;
    }
    container.innerHTML = html;
}

// ==================== 页面加载时获取文件列表 ====================

socket.on('action_files_list', (data) => {
    playbackFileSelect.innerHTML = '<option value="">请选择文件...</option>';
    data.files.forEach(filename => {
        const option = document.createElement('option');
        option.value = filename;
        option.textContent = filename;
        playbackFileSelect.appendChild(option);
    });
});

// 请求文件列表
socket.emit('get_action_files');
```

---

## 在web_control.py中集成控制接口

### 步骤1: 导入ControlAPI
```python
from control_api import ControlAPI, register_control_events
```

### 步骤2: 创建ControlAPI实例
在全局变量定义后添加：
```python
# 创建控制API实例
control_api = ControlAPI(
    socketio=socketio,
    right_controller=right_controller,
    left_controller=left_controller,
    arm_data_dir=ARM_DATA_DIR
)
```

### 步骤3: 注册事件
在Socket.IO事件处理部分添加：
```python
# 注册控制接口事件
register_control_events(socketio, control_api)
```

### 步骤4: 更新全局状态
在需要更新全局状态的地方，同步更新control_api的状态：
```python
# 例如在录制开始时
control_api.recording_active = True
```

---

## 注意事项

1. **文件选择**: 开始播放前必须先选择有效的动作文件
2. **速度范围**: 播放速度建议在0.5-2.0之间，过快可能导致舵机响应不及时
3. **状态刷新**: 状态刷新会自动在重置位姿后触发，也可以手动触发
4. **错误处理**: 所有接口都有错误处理，失败时会通过Socket.IO事件通知前端
5. **并发控制**: 系统不允许同时进行多个操作（录制、播放、同步）

---

## 测试建议

1. **测试播放**: 选择一个动作文件，测试不同速度的播放效果
2. **测试停止**: 在播放过程中点击停止按钮，确认能立即停止
3. **测试重置**: 在不同位姿下点击重置，确认能回到初始位置
4. **测试状态**: 点击刷新状态，确认能正确显示所有舵机的状态信息

---

**文档版本**: 1.0  
**最后更新**: 2026-01-27  
**维护者**: Pico Control System Team
