#V0.2   ä¿®æ­£4 6 å…³èŠ‚ä¸ºæ”¹è£…åçš„å…³èŠ‚è§’åº¦ï¼Œä¸æµ·å°”ç›®å‰çš„ä¿æŒä¸€è‡´ï¼Œä½†åŒ—äº¬çš„è‡‚4 6 å…³èŠ‚ä¸ºæ”¹è£…å‰ 4å…³èŠ‚210åº¦è¶…å‰
        #é™åˆ¶åˆå§‹åŒ–æ—¶æ“ä½œ
#V0.21  ä¿®å¤ä¸æ¨æ‘‡æ†æ—¶ä¸€ç›´ä¸‹å‘0é€Ÿï¼Œå½±å“å¯¼èˆª
#V0.3   èåˆwebç«¯æ§åˆ¶
#V0.41  åˆ°è¾¾è§’åº¦é™åˆ¶åä»¥åŠè§’åº¦çªå˜ï¼Œä»å½“å‰è§’åº¦æ­£è§£å½“å‰ä½å§¿ï¼Œåœ¨æ­£è§£åŸºç¡€ä¸Šç»§ç»­å¢é‡ï¼Œæå‡å¯è¾¾æ€§å’Œç¨³å®šæ€§
#V0.42  æœºæ¢°è‡‚æ§åˆ¶é¢‘ç‡ç¨³å®šåœ¨10HZï¼Œæ–¹å¼æ”¹ä¸ºå®šæ—¶å™¨å›è°ƒï¼Œæå‡ç¨³å®šæ€§
#       ç»Ÿä¸€æ­£è§£å’Œé€†è§£çš„è§’åº¦é™ä½è®¡ç®—æ–¹å¼ï¼Œå‡æŒ‰èˆµæœºè§’åº¦-åç½®è®¡ç®—ï¼Œç®€åŒ–ç†è§£,ikåŠ å…¥é™ä½
#V0.5   ç•¸å½¢è§£åˆ¤æ–­ä¸ä¿®æ­£ï¼Œæå‡IKæ±‚è§£æˆåŠŸç‡ï¼Œä¼˜åŒ–è§’åº¦å¹³æ»‘æ»¤æ³¢å™¨ï¼Œæå‡æœºæ¢°è‡‚ç¨³å®šæ€§ï¼Œç›®æ ‡ä¸å¯è¾¾æ—¶ä¸åŠ¨ä¿æŒä¸Šæ¬¡æˆåŠŸä½å§¿
#V0.1532 å®ç°åŠ¨æ€åˆå§‹çŒœæµ‹ï¼Œæå‡IKæ•ˆç‡ä¸å¹³æ»‘åº¦,ä¸‹å‘moveitæ§åˆ¶ï¼Œä¿®æ­£rpyä½å§¿æ˜ å°„ï¼Œé™åˆ¶æ•°æ®çªå˜ï¼Œå®Œå–„å³è‡‚åŠŸèƒ½
#V0.2   ä¿®æ­£4 6 å…³èŠ‚ä¸ºæ”¹è£…åçš„å…³èŠ‚è§’åº¦ï¼Œä¸æµ·å°”ç›®å‰çš„ä¿æŒä¸€è‡´ï¼Œä½†åŒ—äº¬çš„è‡‚4 6 å…³èŠ‚ä¸ºæ”¹è£…å‰ 4å…³èŠ‚210åº¦è¶…å‰
        #é™åˆ¶åˆå§‹åŒ–æ—¶æ“ä½œ
#V0.21  ä¿®å¤ä¸æ¨æ‘‡æ†æ—¶ä¸€ç›´ä¸‹å‘0é€Ÿï¼Œå½±å“å¯¼èˆª
#V0.3   èåˆwebç«¯æ§åˆ¶
#V0.41  åˆ°è¾¾è§’åº¦é™åˆ¶åä»¥åŠè§’åº¦çªå˜ï¼Œä»å½“å‰è§’åº¦æ­£è§£å½“å‰ä½å§¿ï¼Œåœ¨æ­£è§£åŸºç¡€ä¸Šç»§ç»­å¢é‡ï¼Œæå‡å¯è¾¾æ€§å’Œç¨³å®šæ€§
#V0.42  æœºæ¢°è‡‚æ§åˆ¶é¢‘ç‡ç¨³å®šåœ¨10HZï¼Œæ–¹å¼æ”¹ä¸ºå®šæ—¶å™¨å›è°ƒï¼Œæå‡ç¨³å®šæ€§
#       æœ‰è¯¯å·®ä¸æ‰§è¡Œè§’åº¦æŒ‡ä»¤ï¼Œä¿æŒä¸Šæ¬¡æˆåŠŸä½å§¿
#V0.5   ç•¸å½¢è§£åˆ¤æ–­ä¸ä¿®æ­£ï¼Œæå‡IKæ±‚è§£æˆåŠŸç‡ï¼Œä¼˜åŒ–è§’åº¦å¹³æ»‘æ»¤æ³¢å™¨ï¼Œæå‡æœºæ¢°è‡‚ç¨³å®šæ€§ï¼Œç›®æ ‡ä¸å¯è¾¾æ—¶ä¸åŠ¨ä¿æŒä¸Šæ¬¡æˆåŠŸä½å§¿
#v0.6   ä¿®æ”¹é™ä½ï¼Œé’³åˆ¶åç»­å¢é‡æ§åˆ¶ï¼Œæå‡å¯è¾¾æ€§
#v0.61  ä¿®å¤é™ä½é’³åˆ¶æ—¶ä½å§¿æ¼‚ç§»é—®é¢˜ï¼šè§¦å‘é™ä½åæ­£è§£é’³åˆ¶è§’åº¦æ›´æ–°çœŸå®ä½å§¿ï¼Œä¿è¯ä½å§¿ä¸€è‡´æ€§
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint
from builtin_interfaces.msg import Duration
import socket
import json
import serial
import numpy as np
import time
import os
from roboticstoolbox import DHRobot, RevoluteMDH
from scipy.spatial.transform import Rotation
import threading
import math
import subprocess


# ==============================================================================


#ræ˜¯å·¦å³ç¿»æ»š  pæ˜¯å‰åä¿¯ä»°  yæ˜¯å·¦å³åèˆª

'''
å³è‡‚ç›®æ ‡å§¿æ€(xyz): ['-7.5', '7.4', '57.7']  æ§åˆ¶æ‰‹æŸ„å‘å·¦ç¿»æ»šï¼Œä¹Ÿå°±æ˜¯æ‰‹æŸ„çš„rå€¼ï¼Œå®é™…å³è‡‚æœ«ç«¯æ˜¯å‘ä¸Šä»°
å³è‡‚ç›®æ ‡å§¿æ€(xyz): ['-33.6', '0.4', '-0.2'] æ§åˆ¶æ‰‹æŸ„å‘ä¸Šä»°ï¼Œä¹Ÿå°±æ˜¯æ‰‹æŸ„çš„på€¼ï¼Œå®é™…å³è‡‚æœ«ç«¯æ˜¯å‘å³åèˆª
å³è‡‚ç›®æ ‡å§¿æ€(xyz): ['0.5', '-27.5', '0.6']  æ§åˆ¶æ‰‹æŸ„å‘å·¦åèˆªï¼Œä¹Ÿå°±æ˜¯æ‰‹æŸ„çš„yå€¼ï¼Œå®é™…å³è‡‚æœ«ç«¯æ˜¯å‘å³ç¿»æ»š
'''
LEFT_ARM_PORT = '/dev/ttyUSB10'              # å·¦è‡‚ä¸²å£ç«¯å£
RIGHT_ARM_PORT = '/dev/arm_right'            # å³è‡‚ä¸²å£ç«¯å£
ARM_CONTROL_FREQ = 20                        # æœºæ¢°è‡‚æ§åˆ¶é¢‘ç‡ï¼ˆHzï¼‰è°ƒæ•´ä¸ºV0.3çš„20Hz
CHASSIS_CONTROL_FREQ = 20                    # åº•ç›˜æ§åˆ¶é¢‘ç‡ï¼ˆHzï¼‰
NORMAL_MOVE_TIME_MS = 100                    # æ™®é€šç§»åŠ¨ä¸‹å‘æ—¶é—´ï¼ˆmsï¼‰
RESET_MOVE_TIME_MS = 5000                    # åˆå§‹åŒ–/å¤ä½ä¸‹å‘æ—¶é—´ï¼ˆmsï¼‰
IK_POSITION_TOLERANCE = 0.2                  # é€†è§£å…è®¸çš„æœ€å¤§æœ«ç«¯è¯¯å·®ï¼ˆç±³ï¼‰
IK_EXECUTION_TOLERANCE = 0.001               # é€†è§£æ‰§è¡Œå…è®¸çš„æœ€å¤§è¯¯å·®ï¼ˆç±³ï¼‰ï¼Œè¯¯å·®å¤§äºæ­¤å€¼ä¸æ‰§è¡Œ
POSITION_INCREMENT_SCALE = 0.5               # æœ«ç«¯ä½ç½®å¢é‡ç¼©æ”¾ç³»æ•°
ROTATION_INCREMENT_SCALE = 0.5               # æœ«ç«¯å§¿æ€å¢é‡ç¼©æ”¾ç³»æ•°
MAX_LINEAR_VELOCITY = 0.2                    # åº•ç›˜æœ€å¤§çº¿é€Ÿåº¦ï¼ˆm/sï¼‰
MAX_ANGULAR_VELOCITY = 0.5                   # åº•ç›˜æœ€å¤§è§’é€Ÿåº¦ï¼ˆrad/sï¼‰
MAX_LINEAR_ACCELERATION = 0.2                # åº•ç›˜æœ€å¤§çº¿åŠ é€Ÿåº¦ï¼ˆm/s^2ï¼‰
MAX_ANGULAR_ACCELERATION = 0.5               # åº•ç›˜æœ€å¤§è§’åŠ é€Ÿåº¦ï¼ˆrad/s^2ï¼‰
SERVO_FRAME_HEADER = 0x55                    # èˆµæœºåè®®å¸§å¤´
SERVO_CMD_MOVE = 1                           # èˆµæœºç§»åŠ¨å‘½ä»¤ç 
SERVO_CMD_UNLOAD = 31                        # èˆµæœºå¸åŠ›å‘½ä»¤ç 
SERVO_CMD_READ_POS = 28                      # èˆµæœºè¯»å–ä½ç½®å‘½ä»¤ç 
ANGLE_JUMP_THRESHOLD = 80                    # å•å…³èŠ‚æœ€å¤§å…è®¸è·³å˜ï¼ˆåº¦ï¼‰ï¼Œé˜²æ­¢æœºæ¢°è‡‚çªç„¶æŠ¡è‡‚
LEFT_ARM_REVERSE_JOINTS = [5]            # å·¦è‡‚éœ€è¦åè½¬çš„å…³èŠ‚ç´¢å¼•ï¼ˆ0-basedï¼‰
RIGHT_ARM_REVERSE_JOINTS = [5]           # å³è‡‚éœ€è¦åè½¬çš„å…³èŠ‚ç´¢å¼•ï¼ˆ0-basedï¼Œä¸V0.3ä¿æŒä¸€è‡´ï¼‰
ROBOT_CONFIG = {
    "LEFT_INIT_POSE": [-0.26658, -0.20024, -0.15363],
    "RIGHT_INIT_POSE": [-0.26658, -0.20024, 0.15363],
    "SERVO_IDS": [1, 2, 3, 4, 5, 6, 7],
    "LEFT_INIT_ANGLES":  [120, 120, 120, 210, 120, 120, 80],
    "RIGHT_INIT_ANGLES": [120, 120, 120, 210, 120, 120, 80],
    "JOINT_OFFSETS": [120, 210, 210, 120, 120, 120],
    "SERVO_ANGLE_LIMITS": [
        (0, 240), (120, 240), (15, 235),
        (110, 210), (2, 230), (42, 200),
    ],
    #"SERVO_ANGLE_LIMITS": [
    #    (0, 240), (0, 240), (0, 240),
    #    (0, 240), (0, 240), (0, 240),
    #],
    "LEFT_ARM_JOINT_NAMES": ['L_joint1', 'L_joint2', 'L_joint3', 'L_joint4', 'L_joint5', 'L_joint6'],
    "RIGHT_ARM_JOINT_NAMES": ['R_joint1', 'R_joint2', 'R_joint3', 'R_joint4', 'R_joint5', 'R_joint6'],
}
# ==============================================================================


class VRArmController(Node):
    def __init__(self):
        super().__init__('vr_arm_controller_node')
        self.cmdvel_pub = self.create_publisher(Twist, '/cmd_vel', 10)
        self.left_traj_pub = self.create_publisher(JointTrajectory, '/L_group_controller/joint_trajectory', 10)
        self.right_traj_pub = self.create_publisher(JointTrajectory, '/R_group_controller/joint_trajectory', 10)
        
        self.left_init_pose = np.array(ROBOT_CONFIG["LEFT_INIT_POSE"])
        self.right_init_pose = np.array(ROBOT_CONFIG["RIGHT_INIT_POSE"])
        self.servo_ids = ROBOT_CONFIG["SERVO_IDS"]
        self.left_init_angles = ROBOT_CONFIG["LEFT_INIT_ANGLES"]
        self.right_init_angles = ROBOT_CONFIG["RIGHT_INIT_ANGLES"]
        self.joint_offsets = ROBOT_CONFIG["JOINT_OFFSETS"]
        self.servo_angle_limits = ROBOT_CONFIG["SERVO_ANGLE_LIMITS"]
        self.left_arm_joint_names = ROBOT_CONFIG["LEFT_ARM_JOINT_NAMES"]
        self.right_arm_joint_names = ROBOT_CONFIG["RIGHT_ARM_JOINT_NAMES"]
        
        self.left_current_pose = self.left_init_pose.copy()
        self.right_current_pose = self.right_init_pose.copy()
        self.last_left_pos = None
        self.last_right_pos = None
        self.base_orientation = Rotation.from_euler('zyx', [0, 0, 0])
        self.left_current_rot = self.base_orientation
        self.right_current_rot = self.base_orientation
        self.last_left_rot = None
        self.last_right_rot = None
        self.current_linear_vel = 0.0
        self.current_angular_vel = 0.0
        self.target_joy_x = 0.0
        self.target_joy_y = 0.0
        self.chassis_control_period = 1.0 / CHASSIS_CONTROL_FREQ
        self.last_left_angles_sent = self.left_init_angles.copy()
        self.last_right_angles_sent = self.right_init_angles.copy()
        self.gripper_angle_threshold = 1.0
        self.left_arm_initialized = False
        self.right_arm_initialized = False
        self.position_scale = POSITION_INCREMENT_SCALE
        self.rotation_scale = ROTATION_INCREMENT_SCALE
        self.initial_guess = np.array([0, -np.pi/2, 0, 1.4835, 1.6581, 0])
        self.last_ik_solution_left = self.initial_guess.copy()
        self.last_ik_solution_right = self.initial_guess.copy()
        
        self.create_arm_models()
        self.chassis_timer = self.create_timer(self.chassis_control_period, self.chassis_control_callback)

    def send_angles_to_moveit(self, arm_publisher, joint_names, final_angles_deg, travel_time_ms, arm_name):
        """å°†æœ€ç»ˆèˆµæœºè§’åº¦(0-240)è½¬æ¢ä¸ºä»¥120ä¸ºé›¶ç‚¹çš„moveit!ç†è®ºè§’åº¦(å¼§åº¦)å¹¶å‘å¸ƒ"""
        if len(final_angles_deg) < 6:
            self.get_logger().warn(f"[{arm_name} moveit!] å‘é€è§’åº¦ä¸è¶³6ä¸ªï¼Œå·²è·³è¿‡ã€‚")
            return

        print(f'  [moveit! {arm_name}] æ¥æ”¶åˆ°çš„æœ€ç»ˆä¸‹å‘è§’åº¦(deg): {[f"{a:.2f}" for a in final_angles_deg[:6]]}')
        
        msg = JointTrajectory()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.joint_names = joint_names
        point = JointTrajectoryPoint()
        
        theoretical_angles_rad = []
        for i in range(6):
            # --- æ ¸å¿ƒä¿®æ­£ç‚¹ï¼šä»¥120åº¦ä¸ºæ–°çš„é›¶ç‚¹ ---
            # 1. è·å–æœ€ç»ˆçš„èˆµæœºè§’åº¦
            servo_angle = final_angles_deg[i]
            
            # 2. å°†å…¶å¹³ç§»ï¼Œä½¿120åº¦å¯¹åº”ç†è®ºä¸Šçš„0åº¦
            theoretical_angle_deg = servo_angle - 120.0
            
            # 3. è½¬æ¢ä¸ºå¼§åº¦
            theoretical_angles_rad.append(math.radians(theoretical_angle_deg))

        point.positions = theoretical_angles_rad
        travel_time_sec = travel_time_ms / 1000.0
        point.time_from_start = Duration(sec=int(travel_time_sec), nanosec=int((travel_time_sec % 1) * 1e9))
        
        msg.points.append(point)
        arm_publisher.publish(msg)
        
        angles_rad_str = [f'{rad:+.2f}' for rad in theoretical_angles_rad]
        print(f"  [moveit! {arm_name}] å·²å‘å¸ƒè½¨è¿¹, ç›®æ ‡(rad): {angles_rad_str}")
    
    def chassis_control_callback(self):
        if self.left_arm_initialized and self.right_arm_initialized:
            target_linear_vel = self.target_joy_y * MAX_LINEAR_VELOCITY
            target_angular_vel = -self.target_joy_x * MAX_ANGULAR_VELOCITY
            max_linear_change = MAX_LINEAR_ACCELERATION * self.chassis_control_period
            max_angular_change = MAX_ANGULAR_ACCELERATION * self.chassis_control_period
            linear_diff = np.clip(target_linear_vel - self.current_linear_vel, -max_linear_change, max_linear_change)
            angular_diff = np.clip(target_angular_vel - self.current_angular_vel, -max_angular_change, max_angular_change)
            self.current_linear_vel += linear_diff
            self.current_angular_vel += angular_diff
            # åªæœ‰å½“æ‘‡æ†æœ‰è¾“å…¥æ—¶æ‰å‘å¸ƒé€Ÿåº¦
            if abs(self.target_joy_x) > 1e-3 or abs(self.target_joy_y) > 1e-3 or abs(self.current_linear_vel) > 1e-3 or abs(self.current_angular_vel) > 1e-3:
                twist = Twist()
                twist.linear.x = self.current_linear_vel
                twist.angular.z = self.current_angular_vel
                self.cmdvel_pub.publish(twist)
                print(f"[CMDVEL] æ‘‡æ†:[{self.target_joy_y:+.2f},{self.target_joy_x:+.2f}] -> å‘å¸ƒé€Ÿåº¦:[{self.current_linear_vel:+.2f},{self.current_angular_vel:+.2f}]")
        else:
            if self.current_linear_vel != 0.0 or self.current_angular_vel != 0.0:
                self.cmdvel_pub.publish(Twist())
                self.current_linear_vel = 0.0
                self.current_angular_vel = 0.0
            if abs(self.target_joy_x) > 1e-3 or abs(self.target_joy_y) > 1e-3:
                print("âš ï¸ åº•ç›˜å·²é”å®šï¼Œè¯·å…ˆåˆå§‹åŒ–åŒè‡‚ï¼")

    def create_arm_models(self):
        # é‡‡ç”¨V0.3çš„å®½æ¾DHé™ä½ç­–ç•¥ï¼Œç¡®ä¿IKæ±‚è§£è¿ç»­æ€§
        # åœ¨IKå±‚é¢ä½¿ç”¨å®½æ¾é™ä½ï¼Œåœ¨èˆµæœºå±‚é¢è¿›è¡Œä¸¥æ ¼å®‰å…¨ä¿æŠ¤
        print("ï¿½ é‡‡ç”¨V0.3çš„å®½æ¾DHé™ä½ç­–ç•¥ï¼Œç¡®ä¿IKæ±‚è§£è¿ç»­æ€§...")
        
        self.left_arm = DHRobot([
            RevoluteMDH(d=-0.15363, a=0, alpha=0,         qlim=[0, 4.18879]),
            RevoluteMDH(d=0,        a=0, alpha=np.pi/2,   qlim=[0, 4.18879]),
            RevoluteMDH(d=-0.26658, a=0, alpha=-np.pi/2,  qlim=[0, 4.18879]),
            RevoluteMDH(d=0,        a=0, alpha=np.pi/2,   qlim=[0, 4.18879]),
            RevoluteMDH(d=-0.20024, a=0, alpha=-np.pi/2,  qlim=[0, 4.18879]),
            RevoluteMDH(d=0,        a=0, alpha=np.pi/2,   qlim=[0, 4.18879])
        ], name="Left-arm")
        
        self.right_arm = DHRobot([
            RevoluteMDH(d=0.15363,  a=0, alpha=0,         qlim=[0, 4.18879]),
            RevoluteMDH(d=0,        a=0, alpha=-np.pi/2,  qlim=[0, 4.18879]),
            RevoluteMDH(d=0.26658,  a=0, alpha=np.pi/2,   qlim=[0, 4.18879]),
            RevoluteMDH(d=0,        a=0, alpha=-np.pi/2,  qlim=[0, 4.18879]),
            RevoluteMDH(d=0.20024,  a=0, alpha=np.pi/2,   qlim=[0, 4.18879]),
            RevoluteMDH(d=0,        a=0, alpha=-np.pi/2,  qlim=[0, 4.18879])
        ], name="Right-arm")

    def servo_to_ik_angle(self, sent_angle, joint_index, arm_reverse_joints):
        """å°†èˆµæœºè§’åº¦è½¬æ¢ä¸ºIKç†è®ºè§’åº¦ï¼ˆå…¬å…±å‡½æ•°ï¼‰"""
        offset = self.joint_offsets[joint_index]
        if joint_index in arm_reverse_joints:
            return offset - sent_angle
        else:
            return sent_angle - offset
    
    def ik_to_servo_angle(self, ik_angle, joint_index, arm_reverse_joints):
        """å°†IKç†è®ºè§’åº¦è½¬æ¢ä¸ºèˆµæœºè§’åº¦ï¼ˆå…¬å…±å‡½æ•°ï¼‰"""
        offset = self.joint_offsets[joint_index]
        if joint_index in arm_reverse_joints:
            return offset - ik_angle
        else:
            return ik_angle + offset
    
    def reset_arm_pose_from_current_angles(self, arm_model, sent_angles, arm_reverse_joints):
        """ä»å½“å‰èˆµæœºè§’åº¦æ­£è§£ä½å§¿ï¼ˆå…¬å…±å‡½æ•°ï¼‰"""
        current_joint_angles = []
        for i, sent_angle in enumerate(sent_angles[:6]):
            angle = self.servo_to_ik_angle(sent_angle, i, arm_reverse_joints)
            current_joint_angles.append(angle)
        
        current_angles_rad = np.radians(current_joint_angles)
        fk_result = arm_model.fkine(current_angles_rad)
        return fk_result.t, Rotation.from_matrix(fk_result.R)

    def calculate_arm_ik(self, arm_model, target_position, target_rotation, q0):
        T_target = np.eye(4)
        T_target[:3,:3] = target_rotation.as_matrix()
        T_target[:3,3] = target_position
        ik_solution = arm_model.ikine_LM(Tep=T_target,q0=q0,ilimit=50)
        joint_angles_rad = ik_solution.q
        joint_angles_deg = np.round(np.rad2deg(joint_angles_rad),2).tolist()
        fk_result = arm_model.fkine(joint_angles_rad)
        position_error = np.linalg.norm(target_position-fk_result.t)
        
        # æ£€æŸ¥IKè§£æ˜¯å¦æˆåŠŸä¸”åœ¨é™ä½èŒƒå›´å†…
        if ik_solution.success:
            print(f"    [IK] âœ… æ±‚è§£æˆåŠŸï¼Œä½ç½®è¯¯å·®: {position_error:.4f}m")
        else:
            print(f"    [IK] âš ï¸ æ±‚è§£å¤±è´¥æˆ–è¶…å‡ºå…³èŠ‚é™ä½ï¼Œä½ç½®è¯¯å·®: {position_error:.4f}m")
            
        return joint_angles_deg,position_error,joint_angles_rad

    def unload_all_servos(self, port, arm_name):
        print(f'ğŸ”“ æ­£åœ¨å¸è½½ {arm_name} è‡‚æ‰€æœ‰èˆµæœº...')
        try:
            with serial.Serial(port,baudrate=115200,timeout=1) as ser:
                for servo_id in self.servo_ids:
                    data=[0]
                    packet=[SERVO_FRAME_HEADER,SERVO_FRAME_HEADER,servo_id,3+len(data),SERVO_CMD_UNLOAD]
                    packet.extend(data)
                    checksum = (~sum(packet[2:])) & 0xFF
                    packet.append(checksum)
                    ser.write(bytes(packet))
                    time.sleep(0.01)
            print(f'ğŸ¯ {arm_name} è‡‚æ‰€æœ‰èˆµæœºå·²å¸åŠ›ã€‚')
        except Exception as e:
            print(f'âŒ {arm_name} è‡‚å¸åŠ›å¤±è´¥: {e}')
    
    def _send_servo_command(self, port, angles, time_ms):
        def checksum(data): return (~sum(data[2:])) & 0xFF
        def angle_to_position(angle): return int(np.clip(angle,0,240)/240*1000)
        def send_move_command_packet(ser,servo_id,position,duration):
            pos_low=position&0xFF; pos_high=(position>>8)&0xFF
            time_low=duration&0xFF; time_high=(duration>>8)&0xFF
            packet=[SERVO_FRAME_HEADER,SERVO_FRAME_HEADER,servo_id,7,SERVO_CMD_MOVE,pos_low,pos_high,time_low,time_high]
            packet.append(checksum(packet))
            ser.write(bytes(packet))
        try:
            with serial.Serial(port,baudrate=115200,timeout=1) as ser:
                for idx,angle in enumerate(angles):
                    servo_id = self.servo_ids[idx]
                    position=angle_to_position(angle)
                    send_move_command_packet(ser,servo_id,position,time_ms)
        except Exception as e:
            arm_name="å·¦è‡‚" if "left" in port or "USB10" in port else "å³è‡‚"
            print(f"{arm_name}ä¸²å£å‘é€å¤±è´¥: {e}")

    def read_servo_angles(self, port, servo_ids):
        """è¯»å–æŒ‡å®šèˆµæœºçš„å½“å‰è§’åº¦"""
        def checksum(data): return (~sum(data[2:])) & 0xFF
        def read_servo_position(ser, servo_id):
            # å‘é€è¯»å–ä½ç½®å‘½ä»¤
            packet = [SERVO_FRAME_HEADER, SERVO_FRAME_HEADER, servo_id, 3, SERVO_CMD_READ_POS]
            packet.append(checksum(packet))
            
            ser.flushInput()
            ser.write(bytes(packet))
            time.sleep(0.05)  # ç­‰å¾…å“åº”
            
            if ser.in_waiting > 0:
                data = ser.read(ser.in_waiting)
                if len(data) >= 7 and data[0] == 0x55 and data[1] == 0x55 and data[2] == servo_id:
                    position = data[5] + (data[6] << 8)
                    angle = (position / 1000.0) * 240.0  # è½¬æ¢ä¸ºè§’åº¦
                    return angle
            return None
        
        current_angles = []
        try:
            with serial.Serial(port, baudrate=115200, timeout=0.2) as ser:
                for servo_id in servo_ids:
                    angle = read_servo_position(ser, servo_id)
                    if angle is not None:
                        current_angles.append(angle)
                    else:
                        # å¦‚æœè¯»å–å¤±è´¥ï¼Œä½¿ç”¨ä¸Šæ¬¡è®°å½•çš„è§’åº¦
                        if port == LEFT_ARM_PORT:
                            current_angles.append(self.last_left_angles_sent[len(current_angles)])
                        else:
                            current_angles.append(self.last_right_angles_sent[len(current_angles)])
                        print(f"âš ï¸ è¯»å–èˆµæœºID{servo_id}å¤±è´¥ï¼Œä½¿ç”¨è®°å½•è§’åº¦")
        except Exception as e:
            arm_name = "å·¦è‡‚" if "left" in port or "USB10" in port else "å³è‡‚"
            print(f"âŒ {arm_name}èˆµæœºè§’åº¦è¯»å–å¤±è´¥: {e}")
            # è¿”å›è®°å½•çš„è§’åº¦ä½œä¸ºå¤‡ç”¨
            if port == LEFT_ARM_PORT:
                return self.last_left_angles_sent[:6]
            else:
                return self.last_right_angles_sent[:6]
        
        return current_angles

    def control_left_arm(self, angles, time_ms=100):
        self._send_servo_command(LEFT_ARM_PORT, angles, time_ms)
            
    def control_right_arm(self, angles, time_ms=100):
        self._send_servo_command(RIGHT_ARM_PORT, angles, time_ms)

    def process_arm_data(self, vr_data):
        left_primary = vr_data.get('isLeftPrimary', False)
        right_primary = vr_data.get('isRightPrimary', False)
        left_secondary = vr_data.get('isLeftSecondary', False)
        right_secondary = vr_data.get('isRightSecondary', False)
        
        self.target_joy_x = vr_data.get('rightJoystick', {}).get('x', 0.0)
        self.target_joy_y = vr_data.get('rightJoystick', {}).get('y', 0.0)

        if right_primary and right_secondary:
            print("\n" + "!"*15 + " ç´§æ€¥åœæ­¢è§¦å‘ï¼ " + "!"*15)
            self.target_joy_x = 0.0
            self.target_joy_y = 0.0
            self.unload_all_servos(LEFT_ARM_PORT, "å·¦è‡‚")
            self.unload_all_servos(RIGHT_ARM_PORT, "å³è‡‚")
            if self.left_arm_initialized or self.right_arm_initialized:
                print(" å®‰å…¨é”å·²é‡ç½®ï¼Œæ¾å¼€æŒ‰é”®åéœ€è¦é‡æ–°åˆå§‹åŒ–ã€‚")
                self.left_arm_initialized = False
                self.right_arm_initialized = False
            return

        send_left_cmd = False
        send_right_cmd = False
        new_left_angles = self.last_left_angles_sent.copy()
        new_right_angles = self.last_right_angles_sent.copy()

        if left_secondary:
            print("æ­£åœ¨åˆå§‹åŒ–å·¦è‡‚...")
            self.left_current_pose = self.left_init_pose.copy()
            self.left_current_rot = self.base_orientation
            self.last_left_pos = None
            self.last_left_rot = None
            self.last_ik_solution_left = self.initial_guess.copy()
            new_left_angles = self.left_init_angles.copy()
            send_left_cmd = True
            if not self.left_arm_initialized:
                self.left_arm_initialized = True
                print("âœ… å·¦è‡‚å·²åˆå§‹åŒ–ï¼ŒåŠŸèƒ½å·²è§£é”ã€‚")
            
        if right_secondary:
            print("æ­£åœ¨åˆå§‹åŒ–å³è‡‚...")
            self.right_current_pose = self.right_init_pose.copy()
            self.right_current_rot = self.base_orientation
            self.last_right_pos = None
            self.last_right_rot = None
            self.last_ik_solution_right = self.initial_guess.copy()
            new_right_angles = self.right_init_angles.copy()
            send_right_cmd = True
            if not self.right_arm_initialized:
                self.right_arm_initialized = True
                print("âœ… å³è‡‚å·²åˆå§‹åŒ–ï¼ŒåŠŸèƒ½å·²è§£é”ã€‚")

        left_trigger = vr_data.get('leftTrigger', 0.0)
        right_trigger = vr_data.get('rightTrigger', 0.0)
        
        if self.left_arm_initialized:
            if left_primary:
                lp = vr_data.get('leftPosition', {})
                lq = vr_data.get('leftRotation', {})
                current_left_pos = np.array([lp.get(c, 0) for c in 'xyz'])
                current_left_rot = Rotation.from_quat([lq.get(c, 0) for c in 'xyzw'])
                if self.last_left_pos is not None and self.last_left_rot is not None:
                    pos_delta = (current_left_pos - self.last_left_pos) * self.position_scale
                    mapped_pos_delta = np.array([pos_delta[1], -pos_delta[2], pos_delta[0]])
                    
                    # ä¿å­˜å½“å‰ä½å§¿çŠ¶æ€ï¼Œç”¨äºè¯¯å·®æ—¶å›æ»š
                    prev_pose = self.left_current_pose.copy()
                    prev_rot = self.left_current_rot
                    
                    # å°è¯•æ›´æ–°ä½å§¿
                    self.left_current_pose += mapped_pos_delta
                    rot_delta = current_left_rot * self.last_left_rot.inv()
                    rot_delta_scaled = Rotation.from_rotvec(rot_delta.as_rotvec() * self.rotation_scale)
                    self.left_current_rot = rot_delta_scaled * self.left_current_rot
                    rpy_delta_deg = np.rad2deg(rot_delta_scaled.as_euler('xyz'))
                    print("å·¦è‡‚å¢é‡:")
                    print(f"  - Pos(dx,dy,dz):[{mapped_pos_delta[0]:>6.3f},{mapped_pos_delta[1]:>6.3f},{mapped_pos_delta[2]:>6.3f}]")
                    print(f"  - Rot(d_r,d_p,d_y):[{rpy_delta_deg[0]:>6.1f},{rpy_delta_deg[1]:>6.1f},{rpy_delta_deg[2]:>6.1f}]")
                    print(f"å·¦è‡‚ç›®æ ‡ä½å§¿: {[f'{p:.3f}' for p in self.left_current_pose]}")
                    target_rpy_deg = np.rad2deg(self.left_current_rot.as_euler('zyx'))
                    print(f"å·¦è‡‚ç›®æ ‡å§¿æ€(zyx): {[f'{p:.1f}' for p in target_rpy_deg]}")
                    try:
                        joint_angles, pos_error, solution_rad = self.calculate_arm_ik(self.left_arm, self.left_current_pose, self.left_current_rot, q0=self.last_ik_solution_left)
                        print(f"  [DEBUG] å·¦è‡‚IKè§’åº¦(deg): {[f'{a:.2f}' for a in joint_angles]}")
                        if pos_error <= IK_POSITION_TOLERANCE:
                            # æ·»åŠ æ‰§è¡Œç²¾åº¦æ£€æŸ¥ï¼šè¯¯å·®è¿‡å¤§æ—¶ä¸æ‰§è¡Œè§’åº¦æŒ‡ä»¤ï¼Œå›æ»šä½å§¿ä¿æŒæœºæ¢°è‡‚ä¸åŠ¨
                            if pos_error > IK_EXECUTION_TOLERANCE:
                                print(f"  -> ğŸŸ  å·¦è‡‚IKè¯¯å·®è¿‡å¤§({pos_error:.4f}m > {IK_EXECUTION_TOLERANCE}m)ï¼Œå›æ»šä½å§¿ä¿æŒæœºæ¢°è‡‚ä¸åŠ¨")
                                # å›æ»šåˆ°ä¸Šä¸€æ¬¡æœ‰æ•ˆä½å§¿
                                self.left_current_pose = prev_pose
                                self.left_current_rot = prev_rot
                            else:
                                self.last_ik_solution_left = solution_rad
                                unlimited_arm_angles = [angle + offset for angle, offset in zip(joint_angles, self.joint_offsets)]
                                limited_arm_angles = []
                                is_limited = False
                                for i, angle in enumerate(unlimited_arm_angles):
                                    min_val, max_val = self.servo_angle_limits[i]
                                    clipped_angle = np.clip(angle, min_val, max_val)
                                    if clipped_angle != angle: is_limited = True
                                    limited_arm_angles.append(clipped_angle)
                                if is_limited:
                                    print(f"  -> ğŸŸ¡ å®‰å…¨é™ä½è§¦å‘(å·¦è‡‚)")
                                    print(f"     åŸå§‹è®¡ç®—: {[f'{a:.2f}' for a in unlimited_arm_angles]}")
                                    print(f"     é’³åˆ¶åä¸‹å‘: {[f'{a:.2f}' for a in limited_arm_angles]}")
                                    # ğŸ”§ ä¿®å¤ï¼šé’³åˆ¶åéœ€è¦æ­£è§£å®é™…ä½å§¿ï¼Œé¿å…ä½å§¿æ¼‚ç§»
                                    try:
                                        self.left_current_pose, self.left_current_rot = self.reset_arm_pose_from_current_angles(
                                            self.left_arm, limited_arm_angles, LEFT_ARM_REVERSE_JOINTS)
                                        print(f"     âœ… å·²æ­£è§£é’³åˆ¶åçš„çœŸå®ä½å§¿: {[f'{p:.3f}' for p in self.left_current_pose]}")
                                    except Exception as e:
                                        print(f"     âŒ æ­£è§£é’³åˆ¶ä½å§¿å¤±è´¥: {e}")
                                new_left_angles[:6] = limited_arm_angles
                                send_left_cmd = True
                        elif pos_error > IK_POSITION_TOLERANCE:
                            print(f"  -> å·¦è‡‚ç›®æ ‡ä¸å¯è¾¾, è¯¯å·®={pos_error:.4f}ï¼Œå›æ»šä½å§¿å¹¶ä»å®é™…èˆµæœºè§’åº¦æ­£è§£ï¼")
                            # å›æ»šåˆ°ä¸Šä¸€æ¬¡æœ‰æ•ˆä½å§¿
                            self.left_current_pose = prev_pose
                            self.left_current_rot = prev_rot
                            try:
                                actual_angles = self.read_servo_angles(LEFT_ARM_PORT, self.servo_ids[:6])
                                print(f"ğŸ“– è¯»å–å·¦è‡‚å®é™…èˆµæœºè§’åº¦: {[f'{a:.2f}' for a in actual_angles]}")
                                self.left_current_pose, self.left_current_rot = self.reset_arm_pose_from_current_angles(
                                    self.left_arm, actual_angles, LEFT_ARM_REVERSE_JOINTS)
                                print(f"ğŸ“ é‡ç½®å·¦è‡‚ä½å§¿: {[f'{p:.3f}' for p in self.left_current_pose]}")
                            except Exception as e:
                                print(f"âŒ å·¦è‡‚ä½å§¿é‡ç½®å¤±è´¥: {e}")
                    except Exception as e:
                        print(f"å·¦è‡‚IKè®¡ç®—å¤±è´¥: {e}")
                        # IKè®¡ç®—å¤±è´¥æ—¶ä¹Ÿå›æ»šä½å§¿
                        self.left_current_pose = prev_pose
                        self.left_current_rot = prev_rot
                self.last_left_pos = current_left_pos
                self.last_left_rot = current_left_rot
            else:
                self.last_left_pos = None
                self.last_left_rot = None
            
            target_left_gripper = 80.0 + left_trigger * 40.0
            if abs(target_left_gripper - self.last_left_angles_sent[6]) > self.gripper_angle_threshold:
                final_gripper_angle = max(80, min(120, target_left_gripper))
                print(f"[å·¦å¤¹çˆª] æ‰³æœº:{left_trigger:.3f}->è§’åº¦:{final_gripper_angle:.2f}")
                new_left_angles[6] = final_gripper_angle
                send_left_cmd = True
        elif left_primary or left_trigger > 0.05:
            print("âš ï¸ å·¦è‡‚å·²é”å®šï¼Œè¯·å…ˆæŒ‰ Y é”®åˆå§‹åŒ–ï¼")

        if self.right_arm_initialized:
            if right_primary:
                rp = vr_data.get('rightPosition', {})
                rq = vr_data.get('rightRotation', {})
                current_right_pos = np.array([rp.get(c, 0) for c in 'xyz'])
                # ä¿®æ­£ï¼šæ‰‹æŸ„å››å…ƒæ•°è½¬æ¬§æ‹‰è§’ï¼ˆxyzï¼‰ï¼Œå†æŒ‰xyzé¡ºåºé‡ç»„ä¸ºRotationå¯¹è±¡ï¼Œå®ç°rpyä¸€ä¸€å¯¹åº”
                raw_right_rot = Rotation.from_quat([rq.get(c, 0) for c in 'xyzw'])
                hand_rpy = raw_right_rot.as_euler('xyz')
                # ç‰©ç†è½´é¡ºåºæ˜ å°„ï¼šæœºæ¢°è‡‚roll=æ‰‹æŸ„yawï¼Œpitch=æ‰‹æŸ„rollï¼Œyaw=æ‰‹æŸ„pitch
                arm_rpy = [-hand_rpy[1], hand_rpy[2], -hand_rpy[0]]
                current_right_rot = Rotation.from_euler('xyz', arm_rpy)
                if self.last_right_pos is not None and self.last_right_rot is not None:
                    pos_delta = (current_right_pos - self.last_right_pos) * self.position_scale
                    mapped_pos_delta = np.array([pos_delta[1], -pos_delta[2], pos_delta[0]])
                    
                    # ä¿å­˜å½“å‰ä½å§¿çŠ¶æ€ï¼Œç”¨äºè¯¯å·®æ—¶å›æ»š
                    prev_pose = self.right_current_pose.copy()
                    prev_rot = self.right_current_rot
                    
                    # å°è¯•æ›´æ–°ä½å§¿
                    self.right_current_pose += mapped_pos_delta
                    rot_delta = current_right_rot * self.last_right_rot.inv()
                    rot_delta_scaled = Rotation.from_rotvec(rot_delta.as_rotvec() * self.rotation_scale)
                    self.right_current_rot = rot_delta_scaled * self.right_current_rot
                    rpy_delta_deg = np.rad2deg(rot_delta_scaled.as_euler('xyz'))
                    print("å³è‡‚å¢é‡:")
                    print(f"  - Pos(dx,dy,dz):[{mapped_pos_delta[0]:>6.3f},{mapped_pos_delta[1]:>6.3f},{mapped_pos_delta[2]:>6.3f}]")
                    print(f"  - Rot(d_r,d_p,d_y):[{rpy_delta_deg[0]:>6.1f},{rpy_delta_deg[1]:>6.1f},{rpy_delta_deg[2]:>6.1f}]")
                    print(f"å³è‡‚ç›®æ ‡ä½å§¿: {[f'{p:.3f}' for p in self.right_current_pose]}")

                    target_rpy_deg = np.rad2deg(self.right_current_rot.as_euler('xyz'))
                    print(f"å³è‡‚ç›®æ ‡å§¿æ€(xyz): {[f'{p:.1f}' for p in target_rpy_deg]}")

                    try:
                        joint_angles, pos_error, solution_rad = self.calculate_arm_ik(self.right_arm, self.right_current_pose, self.right_current_rot, q0=self.last_ik_solution_right)
                        print(f"  [DEBUG] å³è‡‚IKè§’åº¦(deg): {[f'{a:.2f}' for a in joint_angles]}")
                        if pos_error <= IK_POSITION_TOLERANCE:
                            # æ·»åŠ æ‰§è¡Œç²¾åº¦æ£€æŸ¥ï¼šè¯¯å·®è¿‡å¤§æ—¶ä¸æ‰§è¡Œè§’åº¦æŒ‡ä»¤ï¼Œå›æ»šä½å§¿ä¿æŒæœºæ¢°è‡‚ä¸åŠ¨
                            if pos_error > IK_EXECUTION_TOLERANCE:
                                print(f"  -> ğŸŸ  å³è‡‚IKè¯¯å·®è¿‡å¤§({pos_error:.4f}m > {IK_EXECUTION_TOLERANCE}m)ï¼Œå›æ»šä½å§¿ä¿æŒæœºæ¢°è‡‚ä¸åŠ¨")
                                # å›æ»šåˆ°ä¸Šä¸€æ¬¡æœ‰æ•ˆä½å§¿
                                self.right_current_pose = prev_pose
                                self.right_current_rot = prev_rot
                            else:
                                self.last_ik_solution_right = solution_rad
                                unlimited_arm_angles = []
                                #å¯¹å…³èŠ‚è¿›è¡Œåè½¬ï¼Œä½¿ç”¨V0.42çš„é…ç½®åŒ–åè½¬é€»è¾‘
                                for i, angle in enumerate(joint_angles):
                                    offset = self.joint_offsets[i]
                                    if i in RIGHT_ARM_REVERSE_JOINTS: 
                                        final_angle = offset - angle
                                    else:
                                        final_angle = angle + offset
                                    unlimited_arm_angles.append(final_angle)
                                limited_arm_angles = []
                                is_limited = False
                                for i, angle in enumerate(unlimited_arm_angles):
                                    min_val, max_val = self.servo_angle_limits[i]
                                    clipped_angle = np.clip(angle, min_val, max_val)
                                    if clipped_angle != angle:
                                        is_limited = True
                                    limited_arm_angles.append(clipped_angle)
                                if is_limited:
                                    print(f"  -> ğŸŸ¡ å®‰å…¨é™ä½è§¦å‘(å³è‡‚)")
                                    print(f"     åŸå§‹è®¡ç®—: {[f'{a:.2f}' for a in unlimited_arm_angles]}")
                                    print(f"     é’³åˆ¶åä¸‹å‘: {[f'{a:.2f}' for a in limited_arm_angles]}")
                                    # ğŸ”§ ä¿®å¤ï¼šé’³åˆ¶åéœ€è¦æ­£è§£å®é™…ä½å§¿ï¼Œé¿å…ä½å§¿æ¼‚ç§»
                                    try:
                                        self.right_current_pose, self.right_current_rot = self.reset_arm_pose_from_current_angles(
                                            self.right_arm, limited_arm_angles, RIGHT_ARM_REVERSE_JOINTS)
                                        print(f"     âœ… å·²æ­£è§£é’³åˆ¶åçš„çœŸå®ä½å§¿: {[f'{p:.3f}' for p in self.right_current_pose]}")
                                    except Exception as e:
                                        print(f"     âŒ æ­£è§£é’³åˆ¶ä½å§¿å¤±è´¥: {e}")
                                new_right_angles[:6] = limited_arm_angles
                                send_right_cmd = True
                        elif pos_error > IK_POSITION_TOLERANCE:
                            print(f"  -> å³è‡‚ç›®æ ‡ä¸å¯è¾¾, è¯¯å·®={pos_error:.4f}ï¼Œå›æ»šä½å§¿å¹¶ä»å®é™…èˆµæœºè§’åº¦æ­£è§£ï¼")
                            # å›æ»šåˆ°ä¸Šä¸€æ¬¡æœ‰æ•ˆä½å§¿
                            self.right_current_pose = prev_pose
                            self.right_current_rot = prev_rot
                            try:
                                actual_angles = self.read_servo_angles(RIGHT_ARM_PORT, self.servo_ids[:6])
                                print(f"ğŸ“– è¯»å–å³è‡‚å®é™…èˆµæœºè§’åº¦: {[f'{a:.2f}' for a in actual_angles]}")
                                self.right_current_pose, self.right_current_rot = self.reset_arm_pose_from_current_angles(
                                    self.right_arm, actual_angles, RIGHT_ARM_REVERSE_JOINTS)
                                print(f"ğŸ“ é‡ç½®å³è‡‚ä½å§¿: {[f'{p:.3f}' for p in self.right_current_pose]}")
                            except Exception as e:
                                print(f"âŒ å³è‡‚ä½å§¿é‡ç½®å¤±è´¥: {e}")
                    except Exception as e:
                        print(f"å³è‡‚IKè®¡ç®—å¤±è´¥: {e}")
                        # IKè®¡ç®—å¤±è´¥æ—¶ä¹Ÿå›æ»šä½å§¿
                        self.right_current_pose = prev_pose
                        self.right_current_rot = prev_rot
                self.last_right_pos = current_right_pos
                self.last_right_rot = current_right_rot
            else:
                self.last_right_pos = None
                self.last_right_rot = None
            
            target_right_gripper = 80.0 + right_trigger * 40.0
            if abs(target_right_gripper - self.last_right_angles_sent[6]) > self.gripper_angle_threshold:
                final_gripper_angle = max(80, min(120, target_right_gripper))
                print(f"[å³å¤¹çˆª] æ‰³æœº:{right_trigger:.3f}->è§’åº¦:{final_gripper_angle:.2f}")
                new_right_angles[6] = final_gripper_angle
                send_right_cmd = True
        elif right_primary or right_trigger > 0.05:
            print("âš ï¸ å³è‡‚å·²é”å®šï¼Œè¯·å…ˆæŒ‰ B é”®åˆå§‹åŒ–ï¼")

        if send_left_cmd:
            final_angles = [max(0, min(240, angle)) for angle in new_left_angles]
            # ä»…åœ¨éåˆå§‹åŒ–æµç¨‹æ—¶åšå…³èŠ‚è·³å˜æ£€æµ‹
            if not left_secondary and self.last_left_angles_sent:
                for i, (last_a, new_a) in enumerate(zip(self.last_left_angles_sent[:6], final_angles[:6])):
                    if abs(new_a - last_a) > ANGLE_JUMP_THRESHOLD:
                        print(f"âš ï¸ å·¦è‡‚å…³èŠ‚{i+1}è§’åº¦çªå˜: {last_a:.2f} -> {new_a:.2f}ï¼Œä»å®é™…èˆµæœºè§’åº¦æ­£è§£ä½å§¿ï¼")
                        # è¯»å–å®é™…èˆµæœºè§’åº¦å¹¶æ­£è§£ä½å§¿
                        try:
                            actual_angles = self.read_servo_angles(LEFT_ARM_PORT, self.servo_ids[:6])
                            print(f"ğŸ“– è¯»å–å·¦è‡‚å®é™…èˆµæœºè§’åº¦: {[f'{a:.2f}' for a in actual_angles]}")
                            self.left_current_pose, self.left_current_rot = self.reset_arm_pose_from_current_angles(
                                self.left_arm, actual_angles, LEFT_ARM_REVERSE_JOINTS)
                            print(f"ğŸ“ é‡ç½®å·¦è‡‚ä½å§¿: {[f'{p:.3f}' for p in self.left_current_pose]}")
                        except Exception as e:
                            print(f"âŒ å·¦è‡‚ä½å§¿é‡ç½®å¤±è´¥: {e}")
                        send_left_cmd = False  # æ£€æµ‹åˆ°çªå˜ï¼Œä¸å‘é€æ‰‹è‡‚å‘½ä»¤ï¼Œä½†ç»§ç»­å¤„ç†å¤¹çˆªç­‰
                        break  # æ£€æµ‹åˆ°ä¸€ä¸ªçªå˜å°±åœæ­¢æ£€æŸ¥ï¼Œé¿å…é‡å¤é‡ç½®
            # æ·»åŠ è§’åº¦å¹³æ»‘ï¼šé™åˆ¶æ¯å¸§æœ€å¤§è§’åº¦å˜åŒ–ï¼Œå‡å°‘æŠ–åŠ¨ä½†ä¿æŒå“åº”æ€§
            if not left_secondary and self.last_left_angles_sent:
                smoothed_angles = []
                max_angle_change_per_frame = 5.0  # åº¦æ¯å¸§ï¼Œè°ƒæ•´æ­¤å€¼æ§åˆ¶å¹³æ»‘ç¨‹åº¦
                for i, target in enumerate(final_angles[:6]):
                    last = self.last_left_angles_sent[i]
                    delta = target - last
                    clamped_delta = np.clip(delta, -max_angle_change_per_frame, max_angle_change_per_frame)
                    smoothed = last + clamped_delta
                    smoothed_angles.append(smoothed)
                smoothed_angles.append(final_angles[6])  # å¤¹çˆªä¸å¹³æ»‘
                final_angles = smoothed_angles
                print(f"  [å¹³æ»‘] å·¦è‡‚å¹³æ»‘åè§’åº¦(deg): {[f'{a:.2f}' for a in final_angles]}")
            print(f"  [DEBUG] å·¦è‡‚æœ€ç»ˆä¸‹å‘è§’åº¦(deg): {[f'{a:.2f}' for a in final_angles]}")
            print(f"  [æ‰§è¡Œ] å·¦è‡‚å½“å‰ä½å§¿: Pos{[f'{p:.3f}' for p in self.left_current_pose]} Rot{[f'{r:.1f}' for r in np.rad2deg(self.left_current_rot.as_euler('zyx'))]}")
            exec_time = RESET_MOVE_TIME_MS if left_secondary else NORMAL_MOVE_TIME_MS
            self.last_left_angles_sent = final_angles.copy()
            #ä¸‹å‘moveitæµ‹è¯•ä½¿ç”¨
            #self.send_angles_to_moveit(self.left_traj_pub, self.left_arm_joint_names, final_angles, exec_time, "å·¦è‡‚")
            self.control_left_arm(final_angles, time_ms=exec_time)
            if left_secondary:
                print("å·¦è‡‚åˆå§‹åŒ–ä¸­ï¼Œè¯·ç­‰å¾…5ç§’é’Ÿ...")
                time.sleep(5)  # åˆå§‹åŒ–åå¼ºåˆ¶ç­‰å¾…5ç§’
                print("å·¦è‡‚åˆå§‹åŒ–å®Œæˆã€‚")

        if send_right_cmd:
            final_angles = [max(0, min(240, angle)) for angle in new_right_angles]
            # ä»…åœ¨éåˆå§‹åŒ–æµç¨‹æ—¶åšå…³èŠ‚è·³å˜æ£€æµ‹
            if not right_secondary and self.last_right_angles_sent:
                for i, (last_a, new_a) in enumerate(zip(self.last_right_angles_sent[:6], final_angles[:6])):
                    if abs(new_a - last_a) > ANGLE_JUMP_THRESHOLD:
                        print(f"âš ï¸ å³è‡‚å…³èŠ‚{i+1}è§’åº¦çªå˜: {last_a:.2f} -> {new_a:.2f}ï¼Œä»å®é™…èˆµæœºè§’åº¦æ­£è§£ä½å§¿ï¼")
                        # è¯»å–å®é™…èˆµæœºè§’åº¦å¹¶æ­£è§£ä½å§¿
                        try:
                            actual_angles = self.read_servo_angles(RIGHT_ARM_PORT, self.servo_ids[:6])
                            print(f"ğŸ“– è¯»å–å³è‡‚å®é™…èˆµæœºè§’åº¦: {[f'{a:.2f}' for a in actual_angles]}")
                            self.right_current_pose, self.right_current_rot = self.reset_arm_pose_from_current_angles(
                                self.right_arm, actual_angles, RIGHT_ARM_REVERSE_JOINTS)
                            print(f"ğŸ“ é‡ç½®å³è‡‚ä½å§¿: {[f'{p:.3f}' for p in self.right_current_pose]}")
                        except Exception as e:
                            print(f"âŒ å³è‡‚ä½å§¿é‡ç½®å¤±è´¥: {e}")
                        send_right_cmd = False  # æ£€æµ‹åˆ°çªå˜ï¼Œä¸å‘é€æ‰‹è‡‚å‘½ä»¤ï¼Œä½†ç»§ç»­å¤„ç†å¤¹çˆªç­‰
                        break  # æ£€æµ‹åˆ°ä¸€ä¸ªçªå˜å°±åœæ­¢æ£€æŸ¥ï¼Œé¿å…é‡å¤é‡ç½®
            # æ·»åŠ è§’åº¦å¹³æ»‘ï¼šé™åˆ¶æ¯å¸§æœ€å¤§è§’åº¦å˜åŒ–ï¼Œå‡å°‘æŠ–åŠ¨ä½†ä¿æŒå“åº”æ€§
            if not right_secondary and self.last_right_angles_sent:
                smoothed_angles = []
                max_angle_change_per_frame = 5.0  # åº¦æ¯å¸§ï¼Œè°ƒæ•´æ­¤å€¼æ§åˆ¶å¹³æ»‘ç¨‹åº¦
                for i, target in enumerate(final_angles[:6]):
                    last = self.last_right_angles_sent[i]
                    delta = target - last
                    clamped_delta = np.clip(delta, -max_angle_change_per_frame, max_angle_change_per_frame)
                    smoothed = last + clamped_delta
                    smoothed_angles.append(smoothed)
                smoothed_angles.append(final_angles[6])  # å¤¹çˆªä¸å¹³æ»‘
                final_angles = smoothed_angles
                print(f"  [å¹³æ»‘] å³è‡‚å¹³æ»‘åè§’åº¦(deg): {[f'{a:.2f}' for a in final_angles]}")
            print(f"  [DEBUG] å³è‡‚æœ€ç»ˆä¸‹å‘è§’åº¦(deg): {[f'{a:.2f}' for a in final_angles]}")
            print(f"  [æ‰§è¡Œ] å³è‡‚å½“å‰ä½å§¿: Pos{[f'{p:.3f}' for p in self.right_current_pose]} Rot{[f'{r:.1f}' for r in np.rad2deg(self.right_current_rot.as_euler('xyz'))]}")
            exec_time = RESET_MOVE_TIME_MS if right_secondary else NORMAL_MOVE_TIME_MS
            self.last_right_angles_sent = final_angles.copy()
            #ä¸‹å‘moveitæµ‹è¯•ä½¿ç”¨
            #self.send_angles_to_moveit(self.right_traj_pub, self.right_arm_joint_names, final_angles, exec_time, "å³è‡‚")
            self.control_right_arm(final_angles, time_ms=exec_time)
            if right_secondary:
                print("å³è‡‚åˆå§‹åŒ–ä¸­ï¼Œè¯·ç­‰å¾…5ç§’é’Ÿ...")
                time.sleep(5)  # åˆå§‹åŒ–åå¼ºåˆ¶ç­‰å¾…5ç§’
                print("å³è‡‚åˆå§‹åŒ–å®Œæˆã€‚")

# ==============================================================================

def start_web_server():
    global web_left_controller, web_right_controller
    try:
        web_left_controller = WebMultiServoController(LEFT_ARM_PORT, 115200, ROBOT_CONFIG["SERVO_IDS"], 'left')
        web_right_controller = WebMultiServoController(RIGHT_ARM_PORT, 115200, ROBOT_CONFIG["SERVO_IDS"], 'right')
        print("Starting Web control server on port 8082...")
        web_socketio.run(web_app, host='0.0.0.0', port=8082, debug=False)
    except Exception as e:
        print(f"Error starting Web server: {e}")

def get_vr_server_ip():
    config_file = 'vr_server_config.txt'
    saved_ip = None
    if os.path.exists(config_file):
        try:
            with open(config_file, 'r') as f:
                saved_ip = f.read().strip()
            print(f"å‘ç°å·²ä¿å­˜çš„VRæœåŠ¡ç«¯IPåœ°å€: {saved_ip}")
        except Exception as e:
            print(f"è¯»å–é…ç½®æ–‡ä»¶å¤±è´¥: {e}")
    if saved_ip:
        print("\nè¯·é€‰æ‹©ï¼š\n1. ä½¿ç”¨å·²ä¿å­˜çš„IPåœ°å€\n2. é‡æ–°è¾“å…¥æ–°çš„IPåœ°å€")
        while True:
            choice = input("è¯·è¾“å…¥é€‰æ‹© (1/2): ").strip()
            if choice == '1': return saved_ip
            elif choice == '2': break
            else: print("è¯·è¾“å…¥æœ‰æ•ˆé€‰æ‹© (1 æˆ– 2)")
    while True:
        try:
            new_ip = input("è¯·è¾“å…¥VRæœåŠ¡ç«¯IPåœ°å€: ").strip()
            parts = new_ip.split('.')
            if len(parts) == 4 and all(0 <= int(part) <= 255 for part in parts):
                try:
                    with open(config_file, 'w') as f: f.write(new_ip)
                    print(f"IPåœ°å€å·²ä¿å­˜åˆ° {config_file}")
                except Exception as e: print(f"ä¿å­˜IPåœ°å€å¤±è´¥: {e}")
                return new_ip
            else: print("IPåœ°å€æ ¼å¼æ— æ•ˆï¼Œè¯·é‡æ–°è¾“å…¥ (ä¾‹å¦‚: 192.168.1.100)")
        except (ValueError, KeyboardInterrupt): print("\nç¨‹åºä¸­æ–­"); exit(0)

def main(args=None):
    rclpy.init(args=args)
    controller_node = VRArmController()
    
    SERVER_HOST = get_vr_server_ip()
    SERVER_PORT = 12345
    
    print(f"VRæ§åˆ¶ç³»ç»Ÿå¯åŠ¨ï¼Œç›®æ ‡æœåŠ¡ç«¯: {SERVER_HOST}:{SERVER_PORT}")
    print("æ“ä½œè¯´æ˜ï¼š")
    print(f"- æ§åˆ¶é¢‘ç‡: åº•ç›˜ {CHASSIS_CONTROL_FREQ}Hz / æœºæ¢°è‡‚ {ARM_CONTROL_FREQ}Hz (Socketçº¿ç¨‹ç›´æ¥å¤„ç†)")
    print("- å®‰å…¨ä¿æŠ¤: åŒé‡é™ä½ç³»ç»Ÿ (IKçº§ + èˆµæœºçº§) ç¡®ä¿æœºæ¢°è‡‚å®‰å…¨")
    print("- å¼ºåˆ¶åˆå§‹åŒ–: è¿æ¥åå¿…é¡»å…ˆæŒ‰ B/Y é”®åˆå§‹åŒ–å¯¹åº”æ‰‹è‡‚ï¼Œæ‰èƒ½è§£é”åŠŸèƒ½ã€‚")
    print("- é¥æ“ä½œ: åˆå§‹åŒ–åï¼Œä¸»æŒ‰é”®ç§»åŠ¨æ‰‹è‡‚ï¼Œæ‰³æœºæ§åˆ¶å¤¹çˆªï¼Œæ‘‡æ†æ§åˆ¶åº•ç›˜ã€‚")
    print("- ç´§æ€¥åœæ­¢: åŒæ—¶æŒ‰ä½å³æ‰‹A+Bé”®ï¼Œåº•ç›˜åœæ­¢ä¸”åŒè‡‚å¸åŠ›ã€‚")
    print("- æŒ‰ Ctrl+C é€€å‡ºç¨‹åº")
    print("="*50)
    
    retry_count = 0
    max_retry_display = 5
    
    def socket_thread_func():
        nonlocal retry_count
        while rclpy.ok():
            try:
                client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                client_socket.settimeout(5)
                if retry_count == 0: print(f"æ­£åœ¨è¿æ¥åˆ°VRæœåŠ¡ç«¯ {SERVER_HOST}:{SERVER_PORT}...")
                elif retry_count < max_retry_display: print(f"é‡è¯•è¿æ¥ä¸­... (ç¬¬{retry_count + 1}æ¬¡)")
                elif retry_count == max_retry_display: print(f"ç»§ç»­ç­‰å¾…æœåŠ¡ç«¯å¯åŠ¨... (åç»­é‡è¯•å°†é™é»˜è¿›è¡Œ)")
                client_socket.connect((SERVER_HOST, SERVER_PORT))
                
                print("âœ… VRæœåŠ¡ç«¯è¿æ¥æˆåŠŸï¼æœºå™¨äººåŠŸèƒ½å·²é”å®šã€‚")
                print("è¯·æŒ‰æ‰‹æŸ„ B æˆ– Y é”®ï¼Œæ‰‹åŠ¨åˆå§‹åŒ–æœºæ¢°è‡‚ä»¥è§£é”ã€‚")
                retry_count = 0
                
                client_socket.setblocking(False)
                buffer = ""
                # é‡‡ç”¨V0.3çš„æ•°æ®å¤„ç†æ¶æ„ï¼šSocketçº¿ç¨‹ç›´æ¥å¤„ç†æ•°æ®
                last_process_time = 0
                arm_control_period = 1.0 / ARM_CONTROL_FREQ

                while rclpy.ok():
                    latest_data_chunk = None
                    while True:
                        try:
                            chunk = client_socket.recv(4096)
                            if not chunk: latest_data_chunk = b''; break
                            latest_data_chunk = chunk
                        except BlockingIOError: break
                    
                    if latest_data_chunk is not None:
                        if not latest_data_chunk:
                            print("âš ï¸ VRæœåŠ¡ç«¯æ–­å¼€è¿æ¥ï¼Œç­‰å¾…é‡æ–°è¿æ¥...")
                            break
                        buffer += latest_data_chunk.decode('utf-8', errors='ignore')

                    # é‡‡ç”¨V0.3æ¶æ„ï¼šç›´æ¥åœ¨Socketçº¿ç¨‹ä¸­å¤„ç†æ•°æ®
                    if '\n' in buffer:
                        messages = buffer.split('\n')
                        for msg in reversed(messages):
                            if msg:
                                try: 
                                    latest_vr_data = json.loads(msg)
                                    # V0.3æ¶æ„ï¼šç›´æ¥å¤„ç†æ•°æ®ï¼Œæ§åˆ¶é¢‘ç‡
                                    current_time = time.time()
                                    if current_time - last_process_time >= arm_control_period:
                                        try:
                                            controller_node.process_arm_data(latest_vr_data)
                                            last_process_time = current_time
                                        except Exception as e:
                                            print(f"æœºæ¢°è‡‚æ§åˆ¶å¤±è´¥: {e}")
                                    break
                                except json.JSONDecodeError: continue
                        buffer = messages[-1] if not buffer.endswith('\n') else ""

                    time.sleep(0.001)
            
            except (socket.timeout, ConnectionRefusedError, ConnectionResetError, BrokenPipeError) as e:
                retry_count += 1
                if isinstance(e, socket.timeout):
                    if retry_count <= max_retry_display: print(f"è¿æ¥è¶…æ—¶ï¼Œæ­£åœ¨é‡è¯•...")
                elif isinstance(e, ConnectionRefusedError):
                    if retry_count == 1: print(f"ç­‰å¾…VRæœåŠ¡ç«¯å¯åŠ¨...")
                else:
                    if retry_count <= max_retry_display: print(f"è¿æ¥é”™è¯¯ ({type(e).__name__})ï¼Œæ­£åœ¨é‡è¯•...")
            except Exception as e:
                retry_count += 1
                if retry_count <= max_retry_display:
                    print(f"è¿æ¥å¤±è´¥: {e}")
            finally:
                try: client_socket.close()
                except: pass
            
            try: time.sleep(3)
            except KeyboardInterrupt: break
    
    socket_thread = threading.Thread(target=socket_thread_func, daemon=True)
    socket_thread.start()

    # å¯åŠ¨ Web æ§åˆ¶æœåŠ¡å™¨
    web_process = subprocess.Popen(['python3', 'web_control.py'], cwd=os.getcwd())

    try:
        rclpy.spin(controller_node)
    except KeyboardInterrupt:
        print("\nğŸ‘‹ ç¨‹åºè¢«ç”¨æˆ·ä¸­æ–­ï¼Œæ­£åœ¨é€€å‡º...")
    finally:
        if web_process:
            web_process.terminate()
            web_process.wait()
        controller_node.destroy_node()
        rclpy.shutdown()
        print("VRæ§åˆ¶å·²åœæ­¢")

if __name__ == "__main__":
    main()